# ClientFE.py
#
# Client-side helper for Functional Encryption (FE) queries.
# - Fetches function‐keys from the authority
# - Sends encrypted queries to the server
# - Verifies and decrypts FE results
# - Falls back to SSE decryption when needed

import os
import socket
import hashlib
import sqlparse
import json
from .fe_scheme import decrypt

# Directory where keys are stored (generated by the authority)
BASE_DIR = os.path.dirname(__file__)
KEY_DIR  = os.path.abspath(os.path.join(BASE_DIR, os.pardir, "keys"))

def load_public_key():
    """
    Load the Paillier public key (n, g) from file.
    Used to encrypt/decrypt FE ciphertexts locally if needed.
    """
    with open(os.path.join(KEY_DIR, "public_key.txt")) as f:
        n, g = map(int, f.read().split())
    return (n, g)

def load_ta_rsa_pub():
    """
    Load the authority's RSA public key (N, e) from file.
    Used to verify the signature on function-keys.
    """
    with open(os.path.join(KEY_DIR, "ta_rsa_pub.txt")) as f:
        N, e = map(int, f.read().split())
    return (N, e)

def get_fkey(query_hash: str) -> str:
    """
    Connect to the authority service to fetch a signed function-key.
    query_hash: SHA-256 hash of the SQL query.
    Returns the token string "FKEY:...|<signature>".
    """
    with socket.socket() as s:
        s.connect(("localhost", 8000))
        cmd = f"GET_FKEY AGG {query_hash}"
        s.sendall(cmd.encode())
        return s.recv(4096).decode().strip()

def get_sse_key() -> int:
    """
    Connect to the authority service to fetch the SSE key.
    Used for simple XOR-based decryption when FE is not applicable.
    """
    with socket.socket() as s:
        s.connect(("localhost", 8000))
        s.sendall(b"GET_SSE_KEY")
        return int(s.recv(4096).decode().strip())

def verify_fkey(token: str, rsa_pub: tuple, expected_hash: str):
    """
    Verify the RSA signature on the function-key token.
    - token: returned by get_fkey, format "data|sig"
    - rsa_pub: (N, e) authority RSA public key
    - expected_hash: the SHA-256 of the query
    Returns the FE secret key (lam, mu) if valid, else None.
    """
    if "|" not in token:
        return None
    data, sig_str = token.split("|", 1)
    try:
        sig = int(sig_str)
    except:
        return None
    N, e = rsa_pub
    # Recompute hash over the data payload
    h = int(hashlib.sha256(data.encode()).hexdigest(), 16) % N
    # Verify signature using RSA
    if pow(sig, e, N) != h:
        return None
    # Parse lam and mu out of the data payload
    parts = dict(p.split(":",1) for p in data.split(";") if ":" in p)
    if parts.get("hash") != expected_hash:
        return None
    return (int(parts["lam"]), int(parts["mu"]))

def send_query(fkey_token: str, sql: str) -> str:
    """
    Send a QUERY message to the FE/SSE server.
    - fkey_token: function‐key token from the authority
    - sql: the SQL SELECT statement
    Returns the raw JSON response as a string.
    """
    msg = f"QUERY\n{fkey_token}\n{sql}"
    chunks = []
    with socket.socket() as s:
        s.connect(("localhost", 9000))
        s.sendall(msg.encode())
        # Read until the server closes
        while True:
            data = s.recv(4096)
            if not data:
                break
            chunks.append(data)
    return b"".join(chunks).decode()

def validate_select(q: str):
    """
    Ensure the query string contains only a single SELECT statement.
    Raises ValueError if not.
    """
    parsed = sqlparse.parse(q)
    if not parsed or parsed[0].get_type() != "SELECT":
        raise ValueError("Only single SELECT statements are allowed.")

def handle_response(resp_json: str,
                    fkey: tuple,
                    public_key: tuple,
                    op: str = None,
                    col: str = None,
                    where: str = None) -> str:
    """
    Process the JSON response from the server and return a human-readable result.
    
    Parameters:
    - resp_json: JSON string returned by send_query()
    - fkey: FE secret key (lam, mu) or None
    - public_key: Paillier public key (n, g)
    - op: aggregate operation ("SUM", "COUNT", "AVG")
    - col: column name or "*"
    - where: WHERE clause string (without the keyword "WHERE")

    Returns:
    A formatted string, e.g. "[FE] SUM = 12345" or "[SSE] SUM = 12345".
    """
    try:
        obj = json.loads(resp_json)
    except json.JSONDecodeError:
        # If it's not valid JSON, just return the raw text
        return resp_json

    mode = obj.get("mode")

    # ---- Functional Encryption path ----
    if mode == "FE":
        fn = obj["fn"]
        if fn == "AVG":
            # FE returns sum and count separately for AVG
            s = decrypt(int(obj["sum"]), fkey, public_key)
            c = obj["count"]
            return f"[FE] AVG = {s}/{c} = {s/c:.2f}"
        else:
            # SUM or COUNT: decrypt the single ciphertext
            val = decrypt(int(obj["cipher"]), fkey, public_key)
            return f"[FE] {fn} = {val}"

    # ---- SSE fallback path ----
    if mode == "SSE_TABLE":
        # 1) Decrypt each row (XOR with the SSE key)
        sse_key  = get_sse_key()
        cols     = obj["columns"]
        enc_rows = obj["rows"]
        dec_rows = []
        for row in enc_rows:
            dr = {
                name: (int(cell) ^ sse_key)
                for name, cell in zip(cols, row)
            }
            dec_rows.append(dr)

        # 2) Apply WHERE filter if provided
        if where:
            import re
            m = re.match(r"^(\w+)\s*(>=|<=|!=|<>|=|<|>)\s*(.+)$", where)
            if m:
                fld, op_sym, lit = m.groups()
                lit = lit.strip("'\"")
                # Try converting literal to number
                try:
                    lit = float(lit)
                except:
                    pass
                ops = {"=":"==","!=":"!=","<>":"!=",
                       ">":">","<":"<",">=":">=", "<=":"<="}
                expr = ops[op_sym]
                dec_rows = [r for r in dec_rows if eval(f"{r[fld]}{expr}{lit}")]

        # 3) Perform the aggregate locally
        if op == "SUM":
            result = sum(r[col] for r in dec_rows)
        elif op == "COUNT":
            result = len(dec_rows)
        elif op == "AVG":
            cnt = len(dec_rows)
            result = (sum(r[col] for r in dec_rows)/cnt) if cnt else 0
        else:
            return f"ERROR: unknown op {op}"

        return f"[SSE] {op} = {result}"

    # Unknown mode
    return f"ERROR: unknown mode {mode}"
